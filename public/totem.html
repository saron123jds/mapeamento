<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MapaF√°cil Market ‚Äì Totem</title>
  <link rel="stylesheet" href="/css/style.css"/>
</head>
<body class="page page--totem">
  <div id="welcomeScreen" class="welcome-screen">
    <div class="welcome-screen__card">
      <div class="welcome-screen__body">
        <div>
          <span class="eyebrow">Bem-vindo(a) ao totem</span>
          <h1>Encontre qualquer produto em poucos toques</h1>
          <p class="muted">Siga os passos abaixo para come√ßar o atendimento.</p>
        </div>
        <ul class="welcome-screen__steps">
          <li><strong>1.</strong> Toque em <em>Iniciar atendimento</em> para abrir a busca.</li>
          <li><strong>2.</strong> Digite o nome, categoria ou corredor do produto desejado.</li>
          <li><strong>3.</strong> Selecione o item para ver a rota no mapa e leve o caminho no celular com o QR Code.</li>
        </ul>
      </div>
      <div class="welcome-screen__actions">
        <button id="startBtn" class="button button--full">Iniciar atendimento</button>
        <p class="muted">O totem volta para esta tela automaticamente quando terminar.</p>
      </div>
    </div>
  </div>

  <div id="experience" hidden>
    <header class="app-header app-header--hero">
      <div class="brand">
        <div class="brand__logo" id="totemLogoWrap" hidden>
          <img id="totemLogo" alt="Logo do totem"/>
        </div>
        <div>
          <span class="eyebrow">Bem-vindo(a) ao</span>
          <h1 class="brand__title" id="totemBrandName">MapaF√°cil Market</h1>
          <p class="muted">Use o buscador inteligente para encontrar produtos e veja o caminho a partir do totem.</p>
        </div>
      </div>
      <nav class="toolbar toolbar--gap-lg">
        <button id="finishBtn" class="button button--ghost danger" type="button">Finalizar atendimento</button>
        <a class="button button--ghost" href="/admin">Admin</a>
      </nav>
    </header>

    <main class="page-grid page-grid--totem">
      <section class="card card--search">
        <div class="card__body">
          <label class="field field--stretch">
            <span class="label">Busque por nome, categoria ou corredor</span>
            <div class="search-bar">
              <span class="search-bar__icon">üîç</span>
              <input class="input input--search" id="query" placeholder="Ex: leite, padaria, corredor 5" autocomplete="off"/>
            </div>
          </label>
        </div>
        <div id="mapWrap" class="map-wrap map-wrap--tall">
          <img id="mapImg" alt="Mapa" class="map-wrap__img"/>
          <div id="pins" class="map-wrap__pins"></div>
          <svg id="overlay" class="map-wrap__overlay" width="100%" height="100%"></svg>
          <div class="map-wrap__hint">Toque em um item da lista para ver o caminho at√© ele.</div>
        </div>
        <div id="qrBox" class="qr-box" hidden>
          <div class="qr-box__image">
            <div id="qrPlaceholder" class="qr-box__status">Selecione um produto para gerar o QR Code.</div>
            <img id="qrImage" alt="QR Code para abrir no celular" hidden/>
          </div>
          <p id="qrMessage" class="qr-box__status"></p>
          <div class="qr-box__link">
            <a id="qrLink" class="button button--ghost" target="_blank" rel="noopener" hidden>Abrir no celular</a>
          </div>
        </div>
      </section>

      <section class="card card--results">
        <div class="card__header">
          <h2>Resultados</h2>
          <p class="muted">Selecione um item para visualizar a rota no mapa.</p>
        </div>
        <div class="card__body">
          <div class="list" id="list"></div>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    import { percentToPx, arrowHead, clamp } from '/js/utils.js';

    const img = document.getElementById('mapImg');
    const mapWrap = document.getElementById('mapWrap');
    const pins = document.getElementById('pins');
    const overlay = document.getElementById('overlay');
    const list = document.getElementById('list');
    const queryEl = document.getElementById('query');
    const totemBrandName = document.getElementById('totemBrandName');
    const totemLogoWrap = document.getElementById('totemLogoWrap');
    const totemLogo = document.getElementById('totemLogo');
    const welcomeScreen = document.getElementById('welcomeScreen');
    const experience = document.getElementById('experience');
    const startBtn = document.getElementById('startBtn');
    const finishBtn = document.getElementById('finishBtn');
    const qrBox = document.getElementById('qrBox');
    const qrImage = document.getElementById('qrImage');
    const qrPlaceholder = document.getElementById('qrPlaceholder');
    const qrMessage = document.getElementById('qrMessage');
    const qrLink = document.getElementById('qrLink');

    let products = [];
    let config = { mapImage: "", entrance: {x:5,y:95}, theme: {} };
    let activeId = null;
    let walkableGrid = null;
    let dotAnimationId = null;
    let activeDot = null;
    let currentMapImage = '';
    let currentView = 'welcome';
    let inactivityTimer = null;
    let shareProductId = null;
    let qrLibPromise = null;
    let dataLoaded = false;

    const INACTIVITY_TIMEOUT = 2 * 60 * 1000;

    const DEFAULT_THEME = {
      primaryColor: '#2563eb',
      secondaryColor: '#1d4ed8',
      backgroundColor: '#f8fafc',
      surfaceColor: '#ffffff',
      textColor: '#0f172a',
      accentColor: '#f97316',
      logo: '',
      brandName: 'MapaF√°cil Market'
    };

    function setQrPlaceholder(text = ''){
      if (!qrPlaceholder) return;
      qrPlaceholder.textContent = text || '';
      qrPlaceholder.hidden = !text;
    }

    function setQrMessage(text = '', isError = false){
      if (!qrMessage) return;
      qrMessage.textContent = text || '';
      qrMessage.hidden = !text;
      qrMessage.classList.toggle('qr-box__status--error', !!isError);
    }

    function hideQrLink(){
      if (!qrLink) return;
      qrLink.hidden = true;
      qrLink.removeAttribute('href');
    }

    function showQrLink(url){
      if (!qrLink) return;
      qrLink.hidden = false;
      qrLink.href = url;
    }

    function clearShare(){
      shareProductId = null;
      if (qrBox){
        qrBox.hidden = true;
      }
      if (qrImage){
        qrImage.src = '';
        qrImage.hidden = true;
      }
      setQrPlaceholder('Selecione um produto para gerar o QR Code.');
      setQrMessage('');
      hideQrLink();
    }

    async function loadQrLib(){
      if (!qrLibPromise){
        qrLibPromise = import('https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/esm/index.min.js')
          .then(mod => mod?.default || mod)
          .catch(err => {
            console.error('Falha ao carregar a biblioteca de QR Code', err);
            return null;
          });
      }
      return qrLibPromise;
    }

    async function showShareForProduct(product){
      if (!product){
        clearShare();
        return;
      }
      shareProductId = product.id;
      if (qrBox){
        qrBox.hidden = false;
      }
      if (qrImage){
        qrImage.hidden = true;
      }
      setQrPlaceholder('Gerando QR Code...');
      setQrMessage('Aponte a c√¢mera do celular para continuar o caminho.');
      hideQrLink();
      let shareUrl = '';
      try {
        const res = await fetch(`/api/share/${encodeURIComponent(product.id)}`);
        if (!res.ok) throw new Error('share-failed');
        const data = await res.json();
        shareUrl = data.url;
        const qrLib = await loadQrLib();
        if (!qrLib || typeof qrLib.toDataURL !== 'function'){ throw new Error('qr-lib'); }
        const dataUrl = await qrLib.toDataURL(shareUrl, { width: 260, margin: 1 });
        if (shareProductId !== product.id) return;
        if (qrImage){
          qrImage.src = dataUrl;
          qrImage.hidden = false;
        }
        setQrPlaceholder('');
        setQrMessage('Escaneie o c√≥digo ou toque em "Abrir no celular" para continuar.');
        showQrLink(shareUrl);
      } catch (err) {
        console.error('Erro ao gerar QR Code', err);
        if (shareProductId !== product?.id) return;
        if (qrImage){
          qrImage.hidden = true;
        }
        setQrPlaceholder('N√£o foi poss√≠vel gerar o QR Code.');
        setQrMessage('Verifique a conex√£o com a internet e tente novamente.', true);
        if (shareUrl){
          showQrLink(shareUrl);
        } else {
          hideQrLink();
        }
      }
    }

    function stopInactivityTimer(){
      if (inactivityTimer){
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
      }
    }

    function resetSearchState(){
      if (queryEl){
        queryEl.value = '';
      }
      activeId = null;
      if (list){
        list.innerHTML = '';
      }
      clearShare();
      renderMap();
    }

    function showWelcomeScreen(){
      currentView = 'welcome';
      stopInactivityTimer();
      if (welcomeScreen) welcomeScreen.hidden = false;
      if (experience) experience.hidden = true;
      resetSearchState();
    }

    function enterSearchMode(){
      currentView = 'search';
      if (welcomeScreen) welcomeScreen.hidden = true;
      if (experience) experience.hidden = false;
      renderMap();
      renderList();
      resetInactivityTimer();
      setTimeout(() => {
        try {
          queryEl?.focus({ preventScroll: true });
        } catch (err) {
          queryEl?.focus();
        }
      }, 50);
    }

    function resetInactivityTimer(){
      if (currentView !== 'search') return;
      stopInactivityTimer();
      inactivityTimer = setTimeout(() => {
        showWelcomeScreen();
      }, INACTIVITY_TIMEOUT);
    }

    function handleUserActivity(){
      if (currentView === 'search'){
        resetInactivityTimer();
      }
    }

    async function loadAll(){
      try {
        const [productsRes, configRes] = await Promise.all([
          fetch('/api/products'),
          fetch('/api/config')
        ]);
        products = await productsRes.json();
        config = await configRes.json();
        dataLoaded = true;
        applyTheme(config.theme);
      } catch (err) {
        console.error('Erro ao carregar dados do totem', err);
        dataLoaded = true;
      } finally {
        renderMap();
        renderList();
      }
    }

    function applyTheme(theme = {}){
      const merged = { ...DEFAULT_THEME, ...theme };
      const root = document.documentElement;
      root.style.setProperty('--primary-color', merged.primaryColor);
      root.style.setProperty('--primary-color-strong', merged.secondaryColor || merged.primaryColor);
      root.style.setProperty('--accent-color', merged.accentColor);
      root.style.setProperty('--background-color', merged.backgroundColor);
      root.style.setProperty('--surface-color', merged.surfaceColor);
      root.style.setProperty('--text-color', merged.textColor);
      root.style.setProperty('--text-muted', shadeColor(merged.textColor, 45));
      totemBrandName.textContent = merged.brandName || DEFAULT_THEME.brandName;
      if (merged.logo){
        totemLogo.src = merged.logo;
        totemLogoWrap.hidden = false;
      } else {
        totemLogo.src = '';
        totemLogoWrap.hidden = true;
      }
      config.theme = merged;
    }

    function shadeColor(hex, percent){
      if (!hex) return '#64748b';
      const num = parseInt(hex.replace('#',''), 16);
      const amt = Math.round(2.55 * percent);
      const r = (num >> 16) + amt;
      const g = (num >> 8 & 0x00FF) + amt;
      const b = (num & 0x0000FF) + amt;
      return '#' + (
        0x1000000 +
        (r<255?(r<0?0:r):255)*0x10000 +
        (g<255?(g<0?0:g):255)*0x100 +
        (b<255?(b<0?0:b):255)
      ).toString(16).slice(1);
    }

    img.addEventListener('load', () => {
      analyzeWalkableGrid();
      renderMap();
    });

    img.addEventListener('error', () => {
      walkableGrid = null;
      renderMap();
    });

    function renderMap(){
      overlay.innerHTML = '';
      pins.innerHTML = '';
      stopDotAnimation();
      if (!activeId){
        clearShare();
      }
      if (config.mapImage){
        if (currentMapImage !== config.mapImage){
          currentMapImage = config.mapImage;
          walkableGrid = null;
          img.src = config.mapImage;
        }
        img.style.display = 'block';
      } else {
        img.style.display = 'none';
        currentMapImage = '';
        walkableGrid = null;
      }
      const entPx = percentToPx(mapWrap, config.entrance);
      addPin(entPx.x, entPx.y, 'Voc√™ est√° aqui');

      if (activeId){
        const p = products.find(pp => pp.id === activeId);
        if (p && p.x!=null && p.y!=null){
          const px = percentToPx(mapWrap, {x:p.x, y:p.y});
          addPin(px.x, px.y, p.name);
          const pathPoints = buildPath(entPx, px, {x:p.x, y:p.y});
          if (pathPoints && pathPoints.length >= 2){
            const polyline = document.createElementNS('http://www.w3.org/2000/svg','polyline');
            polyline.setAttribute('points', pathPoints.map(pt => `${pt.x},${pt.y}`).join(' '));
            polyline.setAttribute('fill', 'none');
            polyline.setAttribute('stroke', 'var(--primary-color)');
            polyline.setAttribute('stroke-width', '3');
            polyline.setAttribute('stroke-linejoin', 'round');
            polyline.setAttribute('stroke-linecap', 'round');
            polyline.setAttribute('stroke-dasharray', '8 8');
            overlay.appendChild(polyline);

            const headFrom = pathPoints[pathPoints.length - 2];
            const headTo = pathPoints[pathPoints.length - 1];
            const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
            poly.setAttribute('points', arrowHead(headFrom, headTo));
            poly.setAttribute('fill', 'var(--primary-color)');
            overlay.appendChild(poly);

            const dot = document.createElement('div');
            dot.className = 'path-dot';
            pins.appendChild(dot);
            activeDot = dot;
            animateDotAlong(pathPoints, dot);
          } else {
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', entPx.x); line.setAttribute('y1', entPx.y);
            line.setAttribute('x2', px.x);    line.setAttribute('y2', px.y);
            line.setAttribute('stroke', 'var(--primary-color)');
            line.setAttribute('stroke-width', '3');
            line.setAttribute('stroke-dasharray', '8 8');
            overlay.appendChild(line);
            const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
            poly.setAttribute('points', arrowHead(entPx, px));
            poly.setAttribute('fill', 'var(--primary-color)');
            overlay.appendChild(poly);

            const dot = document.createElement('div');
            dot.className = 'path-dot';
            pins.appendChild(dot);
            activeDot = dot;
            dot.style.left = entPx.x-6+'px';
            dot.style.top = entPx.y-6+'px';
            animateDotAlong([entPx, px], dot);
          }
        }
      }
    }

    function addPin(x,y,label){
      const pin = document.createElement('div');
      pin.className = 'pin';
      pin.style.left = x+'px';
      pin.style.top = y+'px';
      pin.innerHTML = '<div class="pin-pulse"></div><div class="pin-dot"></div><div class="pin-label">'+label+'</div>';
      pins.appendChild(pin);
    }

    function selectProduct(product){
      if (!product) return;
      activeId = product.id;
      renderMap();
      showShareForProduct(product);
      handleUserActivity();
    }

    function renderList(){
      list.innerHTML = '';
      list.scrollTop = 0;
      if (!dataLoaded){
        const loading = document.createElement('div');
        loading.className = 'empty-state';
        loading.innerHTML = '<strong>Carregando produtos...</strong><p class="muted">Aguarde alguns instantes.</p>';
        list.appendChild(loading);
        return;
      }
      const q = (queryEl.value||'').toLowerCase().trim();
      const items = products.filter(p => {
        return !q || p.name.toLowerCase().includes(q) || (p.category||'').toLowerCase().includes(q) || (p.aisle||'').toLowerCase().includes(q);
      });
      if (items.length===0){
        if (activeId){
          activeId = null;
          renderMap();
        }
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<strong>Nada encontrado.</strong><p class="muted">Tente outros termos ou confira se o produto est√° cadastrado.</p>';
        list.appendChild(empty);
        return;
      }
      items.forEach(p=>{
        const item = document.createElement('button');
        item.className = 'result-card';
        item.setAttribute('type','button');
        item.innerHTML = `
          <div class="result-card__media">
            ${p.photo? `<img src="${p.photo}" alt="${p.name}"/>` : `<div class="result-card__placeholder">${((p.name||'').charAt(0) || '?').toUpperCase()}</div>`}
          </div>
          <div class="result-card__content">
            <div class="result-card__title">${p.name}</div>
            <div class="result-card__meta">${p.category || 'Sem categoria'} ${p.aisle? ' ‚Ä¢ Corredor '+p.aisle:''} ${p.shelf? ' ‚Ä¢ Prateleira '+p.shelf:''} ${p.side? ' ‚Ä¢ '+p.side:''}</div>
          </div>
          <span class="result-card__cta">Ver rota ‚Üí</span>
        `;
        item.onclick = () => selectProduct(p);
        list.appendChild(item);
      });
    }

    startBtn?.addEventListener('click', () => {
      enterSearchMode();
      handleUserActivity();
    });

    finishBtn?.addEventListener('click', () => {
      showWelcomeScreen();
    });

    ['pointerdown','keydown','touchstart'].forEach(evt => {
      document.addEventListener(evt, handleUserActivity, { passive: true });
    });

    queryEl.addEventListener('input', () => {
      renderList();
      handleUserActivity();
    });

    queryEl.addEventListener('focus', handleUserActivity);

    showWelcomeScreen();
    loadAll();

    function analyzeWalkableGrid(){
      if (!img.naturalWidth || !img.naturalHeight) return;
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      const cellSize = Math.max(4, Math.round(Math.min(canvas.width, canvas.height) / 120));
      const cols = Math.max(1, Math.floor(canvas.width / cellSize));
      const rows = Math.max(1, Math.floor(canvas.height / cellSize));
      const grid = Array.from({ length: rows }, () => Array(cols).fill(false));
      const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
      for (let row = 0; row < rows; row++){
        for (let col = 0; col < cols; col++){
          const cx = Math.min(canvas.width - 1, Math.floor((col + 0.5) * cellSize));
          const cy = Math.min(canvas.height - 1, Math.floor((row + 0.5) * cellSize));
          const idx = (cy * canvas.width + cx) * 4;
          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / (3 * 255);
          grid[row][col] = brightness > 0.85;
        }
      }
      walkableGrid = {
        grid,
        rows,
        cols,
        cellSize,
        width: canvas.width,
        height: canvas.height
      };
    }

    function buildPath(entPx, targetPx, targetPercent){
      if (!walkableGrid){
        return [entPx, targetPx];
      }
      const entrancePercent = config.entrance;
      const walkwayPath = findWalkablePath(entrancePercent, targetPercent);
      if (!walkwayPath || walkwayPath.length === 0){
        return [entPx, targetPx];
      }
      const pathPercents = walkwayPath.map(gridToPercent).map(simplifyPercentPrecision);
      const combined = [];
      combined.push(entrancePercent);
      pathPercents.forEach((pt, index) => {
        if (index === 0 && isClose(pt, entrancePercent)) return;
        if (index === pathPercents.length - 1 && isClose(pt, targetPercent)) return;
        combined.push(pt);
      });
      const targetNode = percentToGrid(targetPercent);
      if (isWalkable(targetNode.x, targetNode.y)){
        combined.push(targetPercent);
      }
      const pxPoints = combined.map(percent => percentToPx(mapWrap, percent));
      return dedupePoints(pxPoints);
    }

    function simplifyPercentPrecision(pt){
      return { x: Number(pt.x.toFixed(4)), y: Number(pt.y.toFixed(4)) };
    }

    function dedupePoints(points){
      if (points.length <= 1) return points;
      const result = [points[0]];
      for (let i = 1; i < points.length; i++){
        const prev = result[result.length - 1];
        const current = points[i];
        if (Math.hypot(prev.x - current.x, prev.y - current.y) < 0.5){
          continue;
        }
        result.push(current);
      }
      return result;
    }

    function isClose(a, b){
      return Math.hypot(a.x - b.x, a.y - b.y) < 0.1;
    }

    function percentToGrid(percent){
      const xPx = (percent.x / 100) * walkableGrid.width;
      const yPx = (percent.y / 100) * walkableGrid.height;
      return {
        x: clamp(Math.floor(xPx / walkableGrid.cellSize), 0, walkableGrid.cols - 1),
        y: clamp(Math.floor(yPx / walkableGrid.cellSize), 0, walkableGrid.rows - 1)
      };
    }

    function gridToPercent(node){
      return {
        x: ((node.x + 0.5) * walkableGrid.cellSize / walkableGrid.width) * 100,
        y: ((node.y + 0.5) * walkableGrid.cellSize / walkableGrid.height) * 100
      };
    }

    function nodeKey(x, y){
      return `${x},${y}`;
    }

    function isWalkable(x, y){
      return x >= 0 && x < walkableGrid.cols && y >= 0 && y < walkableGrid.rows && walkableGrid.grid[y][x];
    }

    function nearestWalkable(start){
      if (isWalkable(start.x, start.y)) return start;
      const visited = new Set([nodeKey(start.x, start.y)]);
      const queue = [start];
      const directions = [
        {x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}
      ];
      while (queue.length){
        const current = queue.shift();
        for (const dir of directions){
          const nx = current.x + dir.x;
          const ny = current.y + dir.y;
          const key = nodeKey(nx, ny);
          if (nx < 0 || ny < 0 || nx >= walkableGrid.cols || ny >= walkableGrid.rows || visited.has(key)){
            continue;
          }
          if (isWalkable(nx, ny)){
            return { x: nx, y: ny };
          }
          visited.add(key);
          queue.push({ x: nx, y: ny });
        }
      }
      return null;
    }

    function reconstructPath(cameFrom, current){
      const path = [current];
      let key = nodeKey(current.x, current.y);
      while (cameFrom.has(key)){
        const prev = cameFrom.get(key);
        path.push(prev);
        key = nodeKey(prev.x, prev.y);
      }
      return path.reverse();
    }

    function findWalkablePath(startPercent, endPercent){
      const startNode = percentToGrid(startPercent);
      const endNode = percentToGrid(endPercent);
      const start = nearestWalkable(startNode);
      const goal = nearestWalkable(endNode);
      if (!start || !goal) return null;
      const open = [{ x: start.x, y: start.y, g: 0, f: heuristic(start, goal) }];
      const cameFrom = new Map();
      const gScore = new Map([[nodeKey(start.x, start.y), 0]]);
      const visited = new Set();
      while (open.length){
        open.sort((a, b) => a.f - b.f);
        const current = open.shift();
        const key = nodeKey(current.x, current.y);
        if (visited.has(key)) continue;
        if (current.x === goal.x && current.y === goal.y){
          return simplifyPath(reconstructPath(cameFrom, current));
        }
        visited.add(key);
        const neighbors = [
          { x: current.x + 1, y: current.y },
          { x: current.x - 1, y: current.y },
          { x: current.x, y: current.y + 1 },
          { x: current.x, y: current.y - 1 }
        ];
        for (const nb of neighbors){
          if (!isWalkable(nb.x, nb.y)) continue;
          const nKey = nodeKey(nb.x, nb.y);
          const tentativeG = current.g + 1;
          if (visited.has(nKey)) continue;
          const knownG = gScore.has(nKey) ? gScore.get(nKey) : Infinity;
          if (tentativeG < knownG){
            cameFrom.set(nKey, { x: current.x, y: current.y });
            gScore.set(nKey, tentativeG);
            open.push({ x: nb.x, y: nb.y, g: tentativeG, f: tentativeG + heuristic(nb, goal) });
          }
        }
      }
      return null;
    }

    function heuristic(a, b){
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }

    function simplifyPath(path){
      if (path.length <= 2) return path;
      const result = [path[0]];
      for (let i = 1; i < path.length - 1; i++){
        const prev = result[result.length - 1];
        const current = path[i];
        const next = path[i + 1];
        const d1x = current.x - prev.x;
        const d1y = current.y - prev.y;
        const d2x = next.x - current.x;
        const d2y = next.y - current.y;
        if ((d1x === 0 && d2x === 0) || (d1y === 0 && d2y === 0)){
          continue;
        }
        result.push(current);
      }
      result.push(path[path.length - 1]);
      return result;
    }

    function animateDotAlong(points, dot){
      if (!points || points.length < 2) return;
      const segments = [];
      let totalLength = 0;
      for (let i = 0; i < points.length - 1; i++){
        const start = points[i];
        const end = points[i + 1];
        const length = Math.hypot(end.x - start.x, end.y - start.y);
        segments.push({ start, end, length });
        totalLength += length;
      }
      if (totalLength === 0) return;
      const duration = 1800;
      let direction = 1;
      let progress = 0;
      let lastTimestamp = null;
      dot.style.left = points[0].x - 6 + 'px';
      dot.style.top = points[0].y - 6 + 'px';

      function step(timestamp){
        if (lastTimestamp === null){
          lastTimestamp = timestamp;
        }
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        progress += (delta / duration) * direction;
        if (progress >= 1){
          progress = 1;
          direction = -1;
        } else if (progress <= 0){
          progress = 0;
          direction = 1;
        }
        const distance = progress * totalLength;
        const pos = pointAtDistance(distance, segments);
        dot.style.left = pos.x - 6 + 'px';
        dot.style.top = pos.y - 6 + 'px';
        dotAnimationId = requestAnimationFrame(step);
      }
      dotAnimationId = requestAnimationFrame(step);
    }

    function pointAtDistance(distance, segments){
      let remaining = distance;
      for (const segment of segments){
        if (remaining <= segment.length){
          const t = segment.length === 0 ? 0 : remaining / segment.length;
          return {
            x: segment.start.x + (segment.end.x - segment.start.x) * t,
            y: segment.start.y + (segment.end.y - segment.start.y) * t
          };
        }
        remaining -= segment.length;
      }
      const last = segments[segments.length - 1];
      return { x: last.end.x, y: last.end.y };
    }

    function stopDotAnimation(){
      if (dotAnimationId){
        cancelAnimationFrame(dotAnimationId);
        dotAnimationId = null;
      }
      if (activeDot){
        activeDot.remove();
        activeDot = null;
      }
    }
  </script>
</body>
</html>
